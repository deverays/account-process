import { ListenerMap } from "./Types/ListenerMap";
import { ListenerSignature } from "./Types/ListenerSignature";
import { EmitterOptions } from "./Types/EmitterOptions";
import { ListenerData } from "./Types/ListenerData";
export default class ChocolateMilkEmitter<L extends ListenerSignature<L> = ListenerMap> {
    listeners: Map<keyof L, Array<L[keyof L]>>;
    emitteds: Map<keyof L, boolean>;
    warned: boolean;
    protected emitterOptions: EmitterOptions;
    constructor(emitterOptions?: EmitterOptions);
    on<K extends keyof L>(eventName: K, callback: L[K]): this;
    once<K extends keyof L>(eventName: K, callback: L[K]): this;
    onceAsync<K extends keyof L>(eventName: K): Promise<Parameters<L[K]>>;
    off<K extends keyof L>(eventName: K, callback?: L[K]): this;
    emit<K extends keyof L>(eventName: K, ...parameters: Parameters<L[K]>): ReturnType<L[K]>;
    hasListener<K extends keyof L>(eventName: K, callback?: L[K]): boolean;
    isListened<K extends keyof L>(eventName: K): boolean;
    isEmitted<K extends keyof L>(eventName: K): boolean;
    suspendListener<K extends keyof L>(eventName: K, callback?: L[K]): void;
    unsuspendListener<K extends keyof L>(eventName: K, callback?: L[K]): void;
    isSuspended<K extends keyof L>(eventName: K, callback?: L[K]): boolean;
    modifyListenerData<K extends keyof L>(eventName: K, callback: L[K], listenerData: ListenerData): this;
    static applyOptions(emitterOptions?: EmitterOptions): EmitterOptions;
}
